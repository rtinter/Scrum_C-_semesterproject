# use the official gcc image, based on debian
# can use versions as well, like gcc:5.2
# see https://hub.docker.com/_/gcc/

variables:
  CCACHE_BASEDIR: $CI_PROJECT_DIR
  CCACHE_DIR: $CI_PROJECT_DIR/ccache
  CCACHE_COMPILERCHECK: content

stages:
  - build
  - prepare
  - release

build:
  stage: build
  image: gcc
    # This Job runs in merge requests and also when pushed to main
  # instead of calling g++ directly you can also use some build toolkit like make
  # install the necessary build tools when needed
  
  rules:
    - if: $CI_COMMIT_BRANCH == "dev" || ($CI_PIPELINE_SOURCE == 'merge_request_event' && ( $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "dev" || $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" ))
  before_script:
    - apt update && apt -y install cmake
    - apt -y install libxrandr-dev libxcursor-dev libudev-dev libopenal-dev libflac-dev libvorbis-dev libgl1-mesa-dev libegl1-mesa-dev libxinerama-dev libxi-dev ccache clang-tidy zip
    - ccache --zero-stats  
    - rm -Rf build
    - mkdir build
  script:
    - cd build
    - cmake .. -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_CXX_COMPILER_LAUNCHER=ccache
    - cmake --build . --config Release -j $(nproc)
    - clang-tidy ../src/*.cpp
  cache:
    - key: ccache-$CI_JOB_NAME
      paths:
        - $CCACHE_DIR

prepare:
  image: gcc
  stage: prepare
  rules:
    - if: $CI_COMMIT_TAG
  before_script:
    - apt update && apt -y install cmake
    - apt -y install libxrandr-dev libxcursor-dev libudev-dev libopenal-dev libflac-dev libvorbis-dev libgl1-mesa-dev libegl1-mesa-dev libxinerama-dev libxi-dev ccache clang-tidy zip
    - ccache --zero-stats  
    - rm -Rf build
    - mkdir build
  script:
    - cd build
    - cmake .. -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_CXX_COMPILER_LAUNCHER=ccache
    - cmake --build . --config Release -j $(nproc)
    - zip -j -r release.zip $(pwd)/bin/Athena
    - cp $(pwd)/release.zip $CI_PROJECT_DIR/athena-release-$CI_COMMIT_TAG.zip
    - echo BUILD_JOB_ID=$CI_JOB_ID >> $CI_PROJECT_DIR/build.env
  cache:
    - key: ccache-$CI_JOB_NAME
      paths:
        - $CCACHE_DIR
  artifacts:
    paths:
      - athena-release-$CI_COMMIT_TAG.zip
    reports:
      dotenv: build.env 

release:
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  stage: release
  script:
    - echo "release application..."
    - echo "Application successfully released."
  rules:
    - if: $CI_COMMIT_TAG
  needs:
    - job: prepare
      artifacts: true
  release:
    name: 'Athena $CI_COMMIT_TAG'
    description: '$CI_COMMIT_TAG_MESSAGE'
    # tag_name is a memandatory field and can not be an empty string
    tag_name: '$CI_COMMIT_TAG'
    assets:
      links:
        - name: 'athena-release-$CI_COMMIT_TAG'
          # Use variables to build a URL to access the artifacts
          # ${CI_PROJECT_URL} is the repository URL
          # ${BUILD_JOB_ID} is from the previous job,
          # the build stage, that contains the artifact
          url: '${CI_PROJECT_URL}/-/jobs/${BUILD_JOB_ID}/artifacts/file/athena-release-$CI_COMMIT_TAG.zip'
